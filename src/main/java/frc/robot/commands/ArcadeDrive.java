// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;

import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotController;
//import edu.wpi.first.wpilibj.XboxController;
import frc.robot.subsystems.DriveTrain;
import frc.robot.RobotContainer;
import java.lang.Math;
import edu.wpi.first.wpilibj.Timer;

public class ArcadeDrive extends CommandBase {
        // VARIABLE_DECLARATIONS
        private final DriveTrain m_driveTrain;
        // VARIABLE_DECLARATIONS
        private Joystick stick1;
        double value = 0.0;
        double deadband = .07;
        Timer powerReportTimer = new Timer();
        // CONSTRUCTORS
        public ArcadeDrive(DriveTrain subsystem) {
        // CONSTRUCTORS
        // VARIABLE_SETTING
        // VARIABLE_SETTING
        // REQUIRES
        m_driveTrain = subsystem;
        addRequirements(m_driveTrain);
        // REQUIRES
    }

        // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        stick1 = RobotContainer.getInstance().getDriveStick();
        powerReportTimer.start();
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        m_driveTrain.applyDeadband(value,deadband);
        // values that update constantly, from controller
        double speed = -stick1.getThrottle()*.75; //* .8; //* 0.6;
        double turn = stick1.getTwist()*(.8*.75); //* 0.4; //.3
        if(speed<.01 && speed>-.01){
            turn=0;
        }
        if(turn<.01 && turn>-.01){
            turn=turn-.1;
        }
        /*double cubeSpeed = Math.pow(speed,3.0);
        double cubeTurn = Math.pow(turn,3.0);*/

        /*if(cubeSpeed>1){
            cubeSpeed = 1;
        }
        if(cubeTurn>1){
            cubeTurn=1;
        }*/

        m_driveTrain.drive(speed, turn); //change turn to squareSpeed & SquareTurn for different turning;

        if((powerReportTimer.get()/10)==(int)(powerReportTimer.get()/10)){
            m_driveTrain.getPowerUse();
        }
    //RobotController.setBrownoutVoltage(11); trigger brownout at certain voltage, may be useful at some point
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_driveTrain.drive(0.0, 0.0);
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // DISABLED
        return false;
        // DISABLED
    }
}
