// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.DriveTrain;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class LimelightDrive extends CommandBase {
        // VARIABLE_DECLARATIONS
    private final DriveTrain m_driveTrain;
    NetworkTable table = NetworkTableInstance.getDefault().getTable("limelight");
    NetworkTableEntry tv = table.getEntry("tv"); //If target found
    NetworkTableEntry tx = table.getEntry("tx"); //Horizontal Offset From Crosshair To Target (-27 degrees to 27 degrees)
    NetworkTableEntry ty = table.getEntry("ty"); //Vertical Offset From Crosshair To Target (-20.5 degrees to 20.5 degrees)
    NetworkTableEntry ta = table.getEntry("ta"); //Target Area (0% of image to 100% of image)
    double adjustSteering;
    Timer lLTimer = new Timer();
    double lSpeed, lTurn;
    boolean targetFound;
    boolean finish;
        
        //VARIABLE_DECLARATIONS
    // CONSTRUCTORS
    public LimelightDrive(DriveTrain subsystem) {
        // CONSTRUCTORS
        // VARIABLE_SETTING
        // VARIABLE_SETTING
        // REQUIRES
            m_driveTrain = subsystem;
            addRequirements(m_driveTrain);
        // REQUIRES
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize(){
         //double vifTarget, xOffset, yOffset;
         //double lLSpeed, lLTurn;
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        // read values periodically
        double vifTarget = tv.getDouble(0.0);
        double xOffset = tx.getDouble(0.0);
        double yOffset = ty.getDouble(0.0);
        //post to SmartDashboard periodically
        SmartDashboard.putNumber("LimelightX",xOffset);
        SmartDashboard.putNumber("LimelightY",yOffset);
        SmartDashboard.putNumber("Limelight Target",vifTarget);
        NetworkTableInstance.getDefault().getTable("limelight").getEntry("limelight").setNumber(0); //camera

        while(vifTarget==1){ //target found, may want to add additional conditions
//find constant for relationship between distance and both horizontal and horizontal offsets
            double yOffsetConstant, xOffsetConstant;
            //double lLSpeed = b * yOffsetConstant;
            //double lLTurn = c * xOffsetConstant;
            //height/Math.tan(angle) = distanceToGoal

        }
    }

        //Old stuff, used during autonomous, no longer relevant?
        /*if(lLTimer.get() > 15){   //stops robot completely at 15s to prevent interference with ArcadeDrive variables
            //lSpeed = 0.0;
            //lTurn = 0.0;
            finish=true;                //switch out of autonomous and into teleop
        }else{                          //searches for hub
            if(v==1.0){
                targetFound = true;
                                        //adjust to get to hub, avoid obstacles
                lTurn = lTurn + x;          //adjust turn based on target x
                lSpeed = lSpeed + y;        //adjust speed based on target y
            }else if(v != 1.0 && targetFound==false){
                                        //keep searching
                lSpeed = 0.0;
                lTurn = 1.0; //turns left constantly, could probably change to turn right instead
            }else{
                //set to put ball in the thing.
            }
        }*/
        //m_driveTrain.drive(lSpeed,lTurn);//drives using ArcadeDrive after setting variables to appropriate values
        
        /*if(autoTimer.get() > autoStartTime && autoTimer.get() < autoEndTime){
            //distance = 9.42477796077, 
            lSpeed = .5;
            lTurn = 0;
            m_driveTrain.drive(lSpeed,lTurn);
        }*/
    //}

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_driveTrain.drive(0.0,0.0);
        
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        if (finish==true){
            return true;
        }else{
        return false;
        }
    }

    @Override
    public boolean runsWhenDisabled() {
        // DISABLED
        return false;
        // DISABLED
    }
}
