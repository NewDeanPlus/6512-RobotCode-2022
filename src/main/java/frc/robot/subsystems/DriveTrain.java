// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.PowerDistribution;
//import edu.wpi.first.wpilibj.motorcontrol.Spark;
import edu.wpi.first.wpilibj.PowerDistribution.ModuleType;

/**
 *
 */
public class DriveTrain extends SubsystemBase {
    // CONSTANTS

    // CONSTANTS

    // DECLARATIONS
    public AnalogGyro analogGyro1;
    //private Spark romiLeft, romiRight;
    private CANSparkMax leftC1;
    private CANSparkMax leftC2;
    private MotorControllerGroup leftControllerGroup;
    private CANSparkMax rightC1;
    private CANSparkMax rightC2;
    private MotorControllerGroup rightControllerGroup;
    private DifferentialDrive drive, romiDrive;
    double left; double right;
    double speed;double turn;
    double lSpeed;double lTurn;


    //PDP Objects used to relay power usage info back to you PDP INITIALIZE
  PowerDistribution allPower = new PowerDistribution(0, ModuleType.kCTRE);
  double Tcurrent , Tpower , Tenergy, Icurrent1, Icurrent2, Icurrent3, Icurrent4, Icurrent5, Icurrent6; String powerReport1, powerReport2, powerReport3; //T:total, I:Individual
  
    // DECLARATIONS

    /**
    *
    */
    public DriveTrain() {
        // CONSTRUCTORS
        analogGyro1 = new AnalogGyro(0);
        addChild("AnalogGyro1", analogGyro1);
        analogGyro1.setSensitivity(0.007);

        /*romiLeft = new Spark(0);
        romiLeft.setInverted(false);

        romiRight = new Spark(1);
        romiRight.setInverted(true);*/

        leftC1 = new CANSparkMax(1, MotorType.kBrushless);
        // addChild("leftC1",leftC1);
        leftC1.setInverted(false);

        
          leftC2 = new CANSparkMax(2,MotorType.kBrushless);
    
          // addChild("leftC2",leftC2);
          leftC2.setInverted(false);
       leftC2.follow(leftC1);

        leftControllerGroup = new MotorControllerGroup(leftC1  ,leftC2 );
        addChild("leftControllerGroup", leftControllerGroup);

        rightC1 = new CANSparkMax(3, MotorType.kBrushed);
        //addChild("rightC1",rightC1);
        rightC1.setInverted(false);

        
        rightC2 = new CANSparkMax(4,MotorType.kBrushed);
        //addChild("rightC2",rightC2);
        rightC2.setInverted(false);

        rightC2.follow(rightC1);

        rightControllerGroup = new MotorControllerGroup(rightC1,rightC2); 
        addChild("rightControllerGroup", rightControllerGroup);

        drive = new DifferentialDrive(leftControllerGroup, rightControllerGroup);
        addChild("Drive", drive);
        drive.setSafetyEnabled(true);
        drive.setExpiration(0.1);
        drive.setMaxOutput(1.0);

        /*romiDrive = new DifferentialDrive(romiLeft, romiRight);
        addChild("Drive", romiDrive);
        romiDrive.setSafetyEnabled(true);
        romiDrive.setExpiration(0.1);
        romiDrive.setMaxOutput(1.0);*/
        // CONSTRUCTORS
    }

    @Override
    public void periodic() {
        drive.arcadeDrive(speed,turn);
        //romiDrive.arcadeDrive(speed, turn);
                
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    public void drive(double speed, double turn) {
        this.speed = speed; this.turn = turn;
    }
    public void lDrive(double lSpeed, double lTurn){
        this.lSpeed = lSpeed; this.lTurn = lTurn;
    }
    public void romiDrive(double speed, double turn){
        this.speed=speed; this.turn=turn;
    }
    public double applyDeadband(double value, double deadband) {
    return MathUtil.applyDeadband(value, deadband);
    }
    public AnalogGyro getGyro(){
        return analogGyro1;
    }

    public String[] getPowerUse(){
        Tcurrent = allPower.getTotalCurrent(); //amps
        Tpower = allPower.getTotalPower();     //volts
        Tenergy = allPower.getTotalEnergy();   //watts
        Icurrent1 = allPower.getCurrent(0);
        Icurrent2 = allPower.getCurrent(1);
        Icurrent3 = allPower.getCurrent(2);
        Icurrent4 = allPower.getCurrent(3);
        Icurrent5 = allPower.getCurrent(4);
        Icurrent6 = allPower.getCurrent(6);
        //double[] power = new double[]{Tcurrent,Tpower,Tenergy,Icurrent1,Icurrent2,Icurrent3,Icurrent4,Icurrent5,Icurrent6};
        powerReport1 = "TCrnt: "+Tcurrent+" Amps | TPwr: "+Tpower+" Volts | TEngy: "+Tenergy+" Watts";
        powerReport2 = "Crnt 1(): "+Icurrent1+" Amps | Crnt 2(): "+Icurrent2+" Amps | Crnt 3(): "+Icurrent3+" Amps";
        powerReport3 = "Crnt 4(): "+Icurrent5+" Amps | Crnt 5(): "+Icurrent5+" Amps | Crnt 6(): "+Icurrent6+" Amps";
        String[] totalPowerReport = new String[]{powerReport1,powerReport2,powerReport3};
        return totalPowerReport;
      }
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}
